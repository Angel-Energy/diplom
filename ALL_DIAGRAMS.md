# Все диаграммы проекта «Сообщение 404»

Этот документ содержит 30 диаграмм проекта «Сообщение 404» — текстового квеста в жанре психологического детектива для Android (API 21+). Диаграммы сгруппированы по категориям: архитектурные, данные, API, динамические, игровые, UI/UX и инфраструктурные. Каждая диаграмма представлена в формате Mermaid.js, включает детальное описание в контексте проекта и расширенный вывод о применении. Проект использует Kotlin, Jetpack Compose, MVVM, тёмную тему, офлайн-режим, локальный Ktor-сервер (IP: 192.168.137.1:8080) с MySQL через XAMPP и phpMyAdmin, обеспечивая автономность и соответствие российскому законодательству (152-ФЗ, ГОСТ Р 34.12-2015). Все дубликаты исключены, каждая диаграмма уникальна и относится к одной категории.

## 1. Архитектурные диаграммы

### 1.1. Контейнерная диаграмма (C4 Level 2)

**Описание:** Диаграмма описывает контейнеры системы: Android-приложение (Kotlin, Jetpack Compose, MVVM) имитирует мессенджер с чатами, выборами и мини-играми (Python/JS). Игрок взаимодействует через UI, приложение сохраняет прогресс локально в Room и DataStore (офлайн-режим) и синхронизируется с Ktor-сервером по Wi-Fi (HTTP, TLS 1.2+). Сервер, запущенный на ноутбуке, использует MySQL через XAMPP (база game.db, таблицы: users, game_progress) для хранения прогресса, а phpMyAdmin (порт 80) предоставляет интерфейс управления. Это обеспечивает автономность, исключая интернет-зависимость, и соответствует 152-ФЗ (защита данных).

```mermaid
C4Context
    title Система "Сообщение 404"
    Person(player, Игрок, "Игрок в чат-игре")
    System(androidApp, "Android Приложение", "Kotlin + Jetpack Compose")
    System(server, "Ktor Server", "Локальный сервер")
    SystemDb(db, "MySQL через XAMPP", "Хранение прогресса")
    System(phpMyAdmin, "phpMyAdmin", "Администрирование БД")
    Rel(player, androidApp, "Взаимодействует через UI")
    Rel(androidApp, server, "HTTP-запросы по Wi-Fi")
    Rel(server, db, "Хранение данных")
    Rel(phpMyAdmin, db, "Управление БД")
```

**Вывод:** Диаграмма предоставляет целостный обзор системы, понятный разработчикам, геймдизайнерам и менеджерам. Она помогает настроить локальную сеть (Wi-Fi, XAMPP), спланировать интеграцию (Room ↔ Ktor ↔ MySQL) и тестирование офлайн-режима. Для администраторов она упрощает установку сервера, а для заказчиков — демонстрирует автономность и безопасность.

### 1.2. Компонентная диаграмма (C4 Level 3)

**Описание:** Диаграмма детализирует компоненты Android-приложения: Chat UI (Compose, пузырьки сообщений, тёмная тема), MiniGame Engine (интерпретатор Python/JS для задач по коду), DataStore (настройки, например, тёмная тема), Room (локальное хранение сцен, выборов). Компоненты взаимодействуют через MVVM, синхронизируясь с Ktor-сервером (Retrofit, POST /progress) и MySQL через XAMPP. phpMyAdmin используется для просмотра данных (например, scene_history).

```mermaid
C4Container
    title Компоненты системы
    Enterprise_Boundary(message404) {
        Container(androidApp, "Android App", "Kotlin + Jetpack Compose")
        Container(ktorServer, "Ktor API", "Kotlin")
        Container(mysqlDb, "MySQL через XAMPP", "База данных")
        Container(phpMyAdmin, "phpMyAdmin", "Управление БД")
        Container(chatUi, "Чат UI", "Jetpack Compose")
        Container(miniGameEngine, "Мини-игры", "Python/JS интерпретатор")
        Container(dataStore, "DataStore", "Настройки")
        Container(roomDb, "Room", "Локальное хранение")
    }
    Rel(chatUi, dataStore, "Сохраняет настройки")
    Rel(chatUi, miniGameEngine, "Вызов мини-игры")
    Rel(miniGameEngine, roomDb, "Сохраняет результат")
    Rel(androidApp, ktorServer, "Синхронизация по Wi-Fi")
    Rel(ktorServer, mysqlDb, "Хранение прогресса")
    Rel(phpMyAdmin, mysqlDb, "Управление БД")
```

**Вывод:** Диаграмма помогает разработчикам реализовать модули, поддерживая MVVM и Clean Architecture. Она упрощает модульное тестирование (JUnit для репозиториев, Espresso для UI) и добавление функций (например, аналитика). QA используют её для тестирования интеграции, а геймдизайнеры — для понимания связи чата и мини-игр.

### 1.3. Диаграмма развертывания и сетевой топологии

**Описание:** Диаграмма показывает физическое размещение и Wi-Fi-сеть: ноутбук (Windows/Linux, IP: 192.168.137.1) хостит точку доступа, Ktor-сервер (порт 8080) и MySQL через XAMPP (база game.db). Android-устройства подключаются по Wi-Fi для синхронизации (HTTP, TLS 1.2+). Данные шифруются (AES-256 в Room, TLS на сервере), соответствуя ГОСТ Р 34.12-2015. Room обеспечивает офлайн-режим, минимизируя зависимость от сети.

```mermaid
graph TD
    note "Локальная Wi-Fi сеть"
    Laptop[Ноутбук] -->|Wi-Fi| Android1[Телефон 1]
    Laptop -->|Wi-Fi| Android2[Телефон 2]
    Laptop -->|MySQL| MySQL[(game.db)]
    Laptop -->|Ktor| Android1
    Laptop -->|Ktor| Android2
```

**Вывод:** Диаграмма — руководство для администраторов по настройке Wi-Fi, XAMPP и Ktor. Она минимизирует ошибки конфигурации, обеспечивая стабильную синхронизацию. Разработчики используют её для реализации TLS, а QA — для тестирования офлайн-режима. Менеджеры могут презентовать автономность заказчикам.

### 1.4. Микросервисная архитектура

**Описание:** Диаграмма показывает потенциальное разделение Ktor-сервера на микросервисы: Auth (/auth), Progress (/progress, /save-progress), Content (/scenes, /mini-game). В MVP используется монолитный Ktor, но диаграмма планирует масштабирование, например, для мультиплеера. Все сервисы используют MySQL через XAMPP.

```mermaid
graph LR
    A[Android App] --> B[Auth Service]
    A --> C[Progress Service]
    A --> D[Content Service]
    B --> E[MySQL]
    C --> E
    D --> E
```

**Вывод:** Диаграмма помогает архитекторам спланировать масштабирование, сохраняя простоту MVP. Она полезна для менеджеров при обсуждении с инвесторами, демонстрируя гибкость. Разработчики используют её для оценки монолитной архитектуры, минимизируя сложность.

### 1.5. Диаграмма модулей

**Описание:** Диаграмма описывает структуру пакетов приложения: core (утилиты, Koin DI), data (Room, Retrofit, репозитории), domain (UseCase), presentation (ViewModel, Compose). Это обеспечивает модульность, тестируемость и офлайн-режим, поддерживая Clean Architecture.

```mermaid
classDiagram
    class com.example.message404 {
        +core/
        +data/
        +domain/
        +presentation/
    }
    com.example.message404 --> core
    com.example.message404 --> data
    com.example.message404 --> domain
    com.example.message404 --> presentation
```

**Вывод:** Диаграмма упрощает онбординг разработчиков, обеспечивая навигацию по коду. Она поддерживает модульное тестирование (Mockito) и расширение (например, аналитика). QA используют её для проверки зависимостей, минимизируя регрессии.

### 1.6. Диаграмма слоев

**Описание:** Диаграмма иллюстрирует слои: Presentation (Compose, ViewModel), Domain (UseCase), Data (Room, DataStore, Retrofit). Это разделяет ответственность, поддерживая офлайн-режим (Room) и синхронизацию (Retrofit → Ktor). Соответствует Clean Architecture.

```mermaid
graph TB
    A[Presentation Layer] --> B[Domain Layer]
    B --> C[Data Layer]
    C --> D[Local Storage]
    C --> E[Local Ktor API]
```

**Вывод:** Диаграмма помогает разработчикам соблюдать Clean Architecture, упрощая тестирование и поддержку. Она полезна для QA при проверке слоёв и для менеджеров при оценке архитектурных рисков. Также облегчает добавление функций (например, новые мини-игры).

### 1.7. Диаграмма зависимостей

**Описание:** Диаграмма показывает библиотеки: Kotlin (1.9.x), Jetpack Compose (1.6.x), Coroutines/Flow, Koin, Room, Retrofit, Exposed (ORM для Ktor). Это управляет версиями в build.gradle.kts, обеспечивая совместимость на API 21+.

```mermaid
graph LR
    A[Kotlin] --> B[Jetpack Compose]
    A --> C[Coroutines + Flow]
    A --> D[Koin DI]
    B --> E[MVVM]
    E --> F[Data Layer]
    F --> G[Room]
    F --> H[MySQL via Exposed]
    F --> I[Retrofit]
```

**Вывод:** Диаграмма предотвращает конфликты библиотек, упрощая настройку Gradle. Разработчики используют её для обновления зависимостей, а QA — для тестирования совместимости. Менеджеры оценивают технические риски, планируя обновления.

## 2. Диаграммы данных

### 2.1. Концептуальная модель данных

**Описание:** Диаграмма описывает сущности: Пользователь (анонимный userId), Прогресс (день, сцена), Выборы (диалоги с NPC), Мини-игры (Python/JS задачи), Концовки (финалы). Это основа для сюжета (10 дней, 60+ путей) и базы данных, поддерживающая ветвление и моральные дилеммы.

```mermaid
graph TD
    A[Пользователь] --> B[Прогресс]
    B --> C[Выборы]
    B --> D[Мини-игры]
    B --> E[Концовки]
```

**Вывод:** Диаграмма связывает геймдизайн и разработку, помогая сценаристам проектировать сюжет, а разработчикам — базу данных. Она упрощает тестирование сюжетных путей, обеспечивая разнообразие и офлайн-доступ к данным.

### 2.2. Логическая модель данных

**Описание:** Диаграмма детализирует связи: Пользователь → Прогресс → Сцены (10 дней), Флаги (доверие, угроза), Мини-игры (6 на день). Выборы определяют переходы сцен, влияя на отношения с NPC (Алексей, Елена). Это основа для Room и MySQL.

```mermaid
graph TD
    A[Пользователь] --> B[Прогресс]
    B --> C[Сцены]
    B --> D[Флаги]
    B --> E[Мини-игры]
    C --> F[Выборы]
```

**Вывод:** Диаграмма помогает геймдизайнерам создавать сложные сюжеты, а разработчикам — репозитории и UseCase. QA используют её для тестирования влияния выборов, обеспечивая целостность сюжета и данных.

### 2.3. Физическая модель данных (ERD)

**Описание:** Диаграмма описывает таблицы MySQL: users (userId, name), game_progress (день, сцена, выборы, мини-игры), scene_history (история сцен), flags (доверие, угроза). Room зеркалирует структуру, синхронизируясь через Retrofit. Exposed используется в Ktor.

```mermaid
erDiagram
    USER ||--o{ PROGRESS : has
    PROGRESS ||--o{ SCENE_HISTORY : has
    SCENE_HISTORY ||--o{ FLAG : has
    USER {
        string userId PK
        string name
        datetime created_at
    }
    PROGRESS {
        string userId PK
        int currentDay
        string sceneId
        json choices
        json miniGames
        datetime lastUpdated
    }
    SCENE_HISTORY {
        string userId FK
        string sceneId FK
        text content
        datetime visitedAt
    }
    FLAG {
        string userId FK
        string flagName PK
        string flagValue
        datetime updatedAt
    }
```

**Вывод:** Диаграмма — основа для настройки MySQL и Room. Она упрощает SQL-запросы, управление через phpMyAdmin и тестирование целостности. Разработчики оптимизируют запросы, минимизируя задержки синхронизации.

### 2.4. Диаграмма хранилищ данных

**Описание:** Диаграмма показывает хранилища: Room (прогресс, выборы), DataStore (настройки, тёмная тема), MySQL (серверное хранение). Это управляет данными, поддерживая офлайн-режим и синхронизацию.

```mermaid
graph LR
    A[Room] --> B[Local Storage]
    C[MySQL] --> D[Server Storage]
    E[DataStore] --> B
    F[Игрок] --> A
    F --> C
```

**Вывод:** Диаграмма помогает разработчикам реализовать очистку кэша или резервное копирование. Администраторы используют её для настройки MySQL, а QA — для тестирования синхронизации, минимизируя риск потери данных.

### 2.5. Диаграмма миграции данных

**Описание:** Диаграмма описывает перенос данных: JSON-файлы (сцены, диалоги) импортируются в Room при установке, затем синхронизируются с MySQL через Ktor. Это важно для обновления контента или миграции версий.

```mermaid
graph LR
    A[JSON файлы] --> B[Room]
    B --> C[MySQL через XAMPP]
```

**Вывод:** Диаграмма помогает разработчикам спланировать миграцию без потерь, а QA — тестировать процесс. Геймдизайнеры используют её для обновления контента (например, новые дни), минимизируя ошибки.

## 3. Диаграммы API

### 3.1. Диаграмма конечных точек

**Описание:** Диаграмма описывает Ktor-эндпоинты: /auth (анонимная авторизация, { "userId": "ANON_123" }), /progress (получение прогресса), /save-progress (сохранение, { "day": 1, "choices": [...] }), /scenes (загрузка сцен), /mini-game (данные мини-игр). Все запросы используют TLS 1.2+ и JSON, с кодами ошибок (400, 404).

```mermaid
graph LR
    A[/auth] --> B[/progress]
    B --> C[/save-progress]
    C --> D[/scenes]
    D --> E[/mini-game]
```

**Вывод:** Диаграмма упрощает разработку Retrofit-клиента и Ktor-роутов, а также тестирование API (Postman). QA создают тест-кейсы, а менеджеры планируют расширение API (например, аналитика). Она обеспечивает стабильность и документирование.

### 3.2. Диаграмма состояний API

**Описание:** Диаграмма показывает состояния API: Активен (сервер доступен), Временно недоступен (нет Wi-Fi), Заблокирован (лимит 10 подключений). Это реализует отказоустойчивость на клиенте (уведомления об оффлайне).

```mermaid
stateDiagram-v2
    [*] --> Активен
    Активен --> Временно_недоступен
    Временно_недоступен --> Заблокирован
    Заблокирован --> [*]
```

**Вывод:** Диаграмма улучшает UX, помогая разработчикам реализовать ретраи. QA тестируют сбои Wi-Fi, а администраторы используют её для настройки лимитов, повышая стабильность.

### 3.3. Диаграмма версионирования API

**Описание:** Диаграмма показывает эволюцию API: /api/v1/progress → /api/v2/progress. Это обеспечивает совместимость при обновлениях (например, новые поля в JSON).

```mermaid
graph LR
    A[/api/v1/progress] --> B[/api/v2/progress]
```

**Вывод:** Диаграмма помогает разработчикам поддерживать старые версии, а QA — тестировать совместимость. Менеджеры планируют обновления API, минимизируя риски для пользователей.

### 3.4. Диаграмма ограничений API

**Описание:** Диаграмма описывает ограничения: 10 подключений, доступ по userId, TLS 1.2+. Это защищает сервер и соответствует ГОСТ Р 34.12-2015.

```mermaid
graph TD
    A[Клиент] -->|userId| B[Ktor Server]
    B -->|max 10 connections| C[MySQL]
```

**Вывод:** Диаграмма повышает безопасность, помогая администраторам настроить сервер. Разработчики реализуют ограничения, а QA тестируют стресс-сценарии, обеспечивая соответствие законодательству.

## 4. Динамические диаграммы

### 4.1. Sequence-диаграмма (авторизация)

**Описание:** Диаграмма показывает анонимную авторизацию: клиент отправляет POST /auth, Ktor генерирует userId, сохраняет в MySQL (users) и возвращает { "userId": "ANON_123" }. Используется TLS 1.2+.

```mermaid
sequenceDiagram
    participant A as Android
    participant S as Ktor Server
    participant D as MySQL
    A->>S: POST /auth
    S->>D: INSERT INTO users
    D-->>S: userId
    S-->>A: 200 OK, userId
```

**Вывод:** Диаграмма упрощает реализацию авторизации и тестирование (MockWebServer). Разработчики оптимизируют задержки, а QA проверяют ошибки базы данных, обеспечивая быстрый вход.

### 4.2. State-диаграмма (состояния сессии)

**Описание:** Диаграмма описывает состояния сессии: Новая (вход), Активная (чат/мини-игра), Сохранено локально (офлайн), Синхронизация (Wi-Fi), Завершённая (выход). Это поддерживает автосохранение и офлайн-режим.

```mermaid
stateDiagram-v2
    [*] --> Новая
    Новая --> Активная
    Активная --> Сохранено_локально
    Сохранено_локально --> Синхронизация
    Синхронизация --> Активная
    Активная --> Завершённая
    Завершённая --> [*]
```

**Вывод:** Диаграмма помогает разработчикам управлять сессией, а QA — тестировать офлайн-сценарии. Она улучшает UX, минимизируя потери прогресса при сбоях Wi-Fi.

### 4.3. Activity-диаграмма (сохранение прогресса)

**Описание:** Диаграмма описывает сохранение: игрок делает выбор, приложение проверяет Wi-Fi, сохраняет в Room (офлайн) или отправляет POST /save-progress (онлайн). Данные синхронизируются при подключении.

```mermaid
graph TD
    A[Игрок делает выбор] --> B{Проверка Wi-Fi}
    B -- Есть --> C[POST /save-progress]
    B -- Нет --> D[Сохранение в Room]
    C --> E[Сохранение в MySQL]
    D --> F[Синхронизация при подключении]
```

**Вывод:** Диаграмма обеспечивает надёжное автосохранение, упрощая реализацию и тестирование. Разработчики минимизируют потери данных, а QA проверяют офлайн-сценарии, улучшая UX.

### 4.4. Timing-диаграмма

**Описание:** Диаграмма показывает временные последовательности: запуск (0 мс), загрузка дня (100 мс), выбор игрока (200 мс), синхронизация (250–300 мс). Это оптимизирует производительность на устройствах с 2 ГБ RAM.

```mermaid
sequenceDiagram
    participant A as Android
    participant S as Ktor Server
    Note over A: 0ms: Запуск
    A->>S: 100ms: Загрузка дня
    S-->>A: 150ms: Сцена загружена
    A->>A: 200ms: Выбор игрока
    A->>S: 250ms: Синхронизация
    S-->>A: 300ms: Успех
```

**Вывод:** Диаграмма помогает разработчикам оптимизировать отклик, а QA — тестировать производительность на слабых устройствах. Она выявляет узкие места (например, синхронизация), улучшая UX.

## 5. Игровые диаграммы

### 5.1. Game Loop

**Описание:** Диаграмма описывает цикл игры: загрузка (Room/JSON), рендеринг UI (Compose), обработка ввода (выборы, мини-игры), обновление состояния (флаги, прогресс). Это обеспечивает 60 FPS для чата и мини-игр.

```mermaid
graph TD
    A[Загрузка] --> B[Рендеринг UI]
    B --> C[Обработка ввода]
    C --> D[Обновление состояния]
    D --> A
```

**Вывод:** Диаграмма помогает разработчикам организовать движок, а QA — тестировать плавность. Геймдизайнеры используют её для интеграции механик, а менеджеры — для оценки производительности.

### 5.2. Диаграмма ветвления сцен и диалогов

**Описание:** Диаграмма показывает сцены и диалоги: День 1 включает Сцену 1A/1B, выборы ведут к Дню 2A/2B. Это основа ветвящегося сюжета (10 дней, 60+ путей), влияющего на NPC и концовки.

```mermaid
graph LR
    A[День 1] --> B[Сцена 1A]
    A --> C[Сцена 1B]
    B --> D[Выбор 1]
    B --> E[Выбор 2]
    D --> F[День 2A]
    E --> G[День 2B]
```

**Вывод:** Диаграмма помогает геймдизайнерам проектировать сюжет, а QA — тестировать пути. Разработчики реализуют ветвление (Room, Ktor), а менеджеры оценивают реиграбельность.

### 5.3. Диаграмма состояний персонажа

**Описание:** Диаграмма описывает отношения с NPC (Алексей, Елена): Нейтральный, Дружелюбный, Враг. Выборы игрока (например, доверие Елене) определяют переходы, влияя на сюжет.

```mermaid
stateDiagram-v2
    [*] --> Нейтральный
    Нейтральный --> Дружелюбный
    Нейтральный --> Враг
    Дружелюбный --> Нейтральный
    Враг --> Нейтральный
```

**Вывод:** Диаграмма упрощает моделирование отношений, помогая геймдизайнерам создавать дилеммы. Разработчики реализуют флаги, а QA тестируют влияние выборов, обеспечивая динамичность.

### 5.4. Диаграмма баланса игры

**Описание:** Диаграмма показывает соотношение: диалоги (30%), мини-игры (40%), концовки (20%), документы (10%). Это балансирует опыт для аудитории 16+.

```mermaid
pie
    title Баланс игровых элементов
    "Диалоги" : 30
    "Мини-игры" : 40
    "Концовки" : 20
    "Документы" : 10
```

**Вывод:** Диаграмма помогает геймдизайнерам сбалансировать контент, а QA — тестировать равномерность. Менеджеры планируют DLC, а разработчики оптимизируют ресурсы.

### 5.5. Диаграмма прогрессии

**Описание:** Диаграмма показывает переходы: День 1 → День 2 → Финал, с ветвлением (День 2A/2B). Это обеспечивает линейность с вариативностью.

```mermaid
graph LR
    A[День 1] --> B[День 2]
    B --> C[День 3]
    C --> D[Финал]
```

**Вывод:** Диаграмма помогает геймдизайнерам структурировать дни, а QA — проверять концовки. Разработчики реализуют прогрессию в Room, а менеджеры оценивают длительность игры.

## 6. UI/UX диаграммы

### 6.1. User Flow

**Описание:** Диаграмма описывает путь игрока: запуск, вход (анонимный), чат (диалоги с NPC), выборы, мини-игры, сохранение, выход. Это обеспечивает интуитивный UX в тёмной теме.

```mermaid
graph TD
    A[Запуск] --> B[Вход]
    B --> C[Чат]
    C --> D[Выбор]
    D --> E[Мини-игра]
    E --> F[Сохранение]
    F --> G[Выход]
```

**Вывод:** Диаграмма помогает UX-дизайнерам создать интуитивный интерфейс, а QA — тестировать сценарии. Разработчики реализуют NavController, а менеджеры презентуют UX заказчикам.

### 6.2. Диаграмма навигации

**Описание:** Диаграмма показывает навигацию Jetpack Navigation: nav_start → nav_chat → nav_minigame → nav_settings → nav_endings. Это обеспечивает плавные переходы в портретном режиме.

```mermaid
graph LR
    A[nav_start] --> B[nav_chat]
    B --> C[nav_minigame]
    B --> D[nav_settings]
    C --> E[nav_endings]
```

**Вывод:** Диаграмма упрощает настройку NavController, минимизируя баги. QA тестируют маршруты, а разработчики обеспечивают плавность переходов, улучшая UX.

### 6.3. Диаграмма состояний UI

**Описание:** Диаграмма описывает состояния UI: Загрузка (прогресс-бар), Активный (чат/мини-игра), Оффлайн (уведомление), Завершённая (выход). Это обеспечивает стабильный UX.

```mermaid
stateDiagram-v2
    [*] --> Загрузка
    Загрузка --> Активный
    Активный --> Оффлайн
    Оффлайн --> Завершённая
    Завершённая --> [*]
```

**Вывод:** Диаграмма помогает разработчикам тестировать UI-состояния (Compose), а QA — проверять поведение при сбоях Wi-Fi. Она улучшает UX, делая интерфейс предсказуемым.

### 6.4. Прототипы экранов

**Описание:** Диаграмма показывает макеты: чат (пузырьки, кнопки выбора), мини-игра (редактор кода, кнопка «Выполнить»), настройки (тёмная тема). Это основа для портретного UI.

```mermaid
graph TD
    A[Чат] -->|Mockup| B[Пузырьки сообщений]
    A --> C[Кнопки выбора]
    D[Мини-игра] --> E[Редактор кода]
    D --> F[Кнопка "Выполнить"]
    G[Настройки] --> H[Переключатель темы]
```

**Вывод:** Диаграмма ускоряет создание UI, согласовывая дизайн и разработку. QA тестируют доступность (TalkBack), а разработчики реализуют тёмную тему, соответствующую WCAG 2.1.

## 7. Инфраструктурные диаграммы

### 7.1. Диаграмма мониторинга

**Описание:** Диаграмма показывает мониторинг через phpMyAdmin: разработчик просматривает таблицы (users, game_progress) для отладки или анализа прогресса игроков.

```mermaid
sequenceDiagram
    participant D as Разработчик
    participant P as phpMyAdmin
    participant M as MySQL
    D->>P: Вход через браузер
    P->>M: SQL-запрос
    M-->>P: Данные
    P-->>D: Визуализация
```

**Вывод:** Диаграмма упрощает администрирование, помогая выявлять проблемы с данными. Разработчики используют её для отладки, а QA — для анализа багов, повышая надёжность.

### 7.2. Диаграмма резервного копирования

**Описание:** Диаграмма описывает резервное копирование: ежедневный экспорт MySQL в CSV/JSON через phpMyAdmin и ручной экспорт. Это защищает данные от сбоев.

```mermaid
graph LR
    A[MySQL] --> B[Ежедневная копия]
    A --> C[Ручной экспорт CSV/JSON]
```

**Вывод:** Диаграмма помогает администраторам настроить резервное копирование, минимизируя потери данных. Разработчики используют её для восстановления базы, а QA — для тестирования бэкапов.
